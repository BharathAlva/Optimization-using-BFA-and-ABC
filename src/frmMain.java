
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Polygon;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JOptionPane;
import javax.swing.JPanel;

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Sanket & team
 */
public class frmMain extends javax.swing.JFrame {

    /**
     * Creates new form frmMain
     */
     
    public frmMain() {
        try{
        initComponents();
        }
        catch(Exception ex)
        {
            System.out.println("exp caught"+ex.getMessage());
            
        }
    }
    
   

           
    

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        size = new javax.swing.JTextField();
        manet = new javax.swing.JButton();
        show_hide = new javax.swing.JButton();
        stopMovement = new javax.swing.JButton();
        route = new javax.swing.JButton();
        source = new javax.swing.JTextField();
        dest = new javax.swing.JTextField();
        jButton2 = new javax.swing.JButton();
        send = new javax.swing.JButton();
        delayToggle = new javax.swing.JButton();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        nodeTab = new javax.swing.JTabbedPane();
        jScrollPane1 = new javax.swing.JScrollPane();
        /*
        design = new javax.swing.JPanel();
        */ design= new myPanel();
        jPanel3 = new javax.swing.JPanel();
        jScrollPane2 = new javax.swing.JScrollPane();
        /*
        infoPanel = new javax.swing.JPanel();
        */ infoPanel = new myInfoPanel();
        jPanel4 = new javax.swing.JPanel();
        region_info = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setBackground(new java.awt.Color(255, 255, 0));
        setFocusTraversalPolicyProvider(true);

        jPanel1.setBackground(new java.awt.Color(102, 102, 255));

        size.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sizeActionPerformed(evt);
            }
        });

        manet.setBackground(new java.awt.Color(204, 204, 204));
        manet.setText("manet");
        manet.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                manetActionPerformed(evt);
            }
        });

        show_hide.setBackground(new java.awt.Color(204, 204, 204));
        show_hide.setText("show/hide");
        show_hide.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                show_hideActionPerformed(evt);
            }
        });

        stopMovement.setBackground(new java.awt.Color(204, 204, 204));
        stopMovement.setText("stop movement");
        stopMovement.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                stopMovementActionPerformed(evt);
            }
        });

        route.setBackground(new java.awt.Color(204, 204, 204));
        route.setText("link");
        route.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                routeActionPerformed(evt);
            }
        });

        dest.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                destActionPerformed(evt);
            }
        });

        jButton2.setBackground(new java.awt.Color(204, 204, 204));
        jButton2.setText("Clear");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        send.setBackground(new java.awt.Color(204, 204, 204));
        send.setText("send");
        send.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sendActionPerformed(evt);
            }
        });

        delayToggle.setBackground(new java.awt.Color(204, 204, 204));
        delayToggle.setText("Turn Delay ON");
        delayToggle.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                delayToggleActionPerformed(evt);
            }
        });

        jLabel2.setText("Enter No. of Nodes");

        jLabel3.setText("src");

        jLabel4.setText("des");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(size, javax.swing.GroupLayout.PREFERRED_SIZE, 51, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(19, 19, 19))
                    .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addGroup(jPanel1Layout.createSequentialGroup()
                            .addComponent(jLabel3)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jLabel4))
                        .addComponent(route, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(manet, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 91, Short.MAX_VALUE)))
                .addGap(21, 21, 21))
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(20, 20, 20)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addComponent(jButton2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(stopMovement, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 102, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, Short.MAX_VALUE))))
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(19, 19, 19)
                        .addComponent(send, javax.swing.GroupLayout.PREFERRED_SIZE, 79, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(source, javax.swing.GroupLayout.PREFERRED_SIZE, 47, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(dest, javax.swing.GroupLayout.PREFERRED_SIZE, 47, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addComponent(show_hide, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(delayToggle, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(10, 10, 10)
                .addComponent(jLabel2)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(size, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(manet)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(route)
                .addGap(24, 24, 24)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel3)
                    .addComponent(jLabel4))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(source, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(dest, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(send)
                .addGap(38, 38, 38)
                .addComponent(delayToggle)
                .addGap(18, 18, 18)
                .addComponent(show_hide)
                .addGap(60, 60, 60)
                .addComponent(jButton2)
                .addGap(48, 48, 48)
                .addComponent(stopMovement)
                .addContainerGap(369, Short.MAX_VALUE))
        );

        nodeTab.setBackground(new java.awt.Color(255, 255, 102));

        design.setBackground(new java.awt.Color(204, 204, 204));
        design.setPreferredSize(new java.awt.Dimension(8000, 8000));

        javax.swing.GroupLayout designLayout = new javax.swing.GroupLayout(design);
        design.setLayout(designLayout);
        designLayout.setHorizontalGroup(
            designLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 8000, Short.MAX_VALUE)
        );
        designLayout.setVerticalGroup(
            designLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 8000, Short.MAX_VALUE)
        );

        jScrollPane1.setViewportView(design);

        nodeTab.addTab("design", jScrollPane1);

        infoPanel.setBackground(new java.awt.Color(119, 12, 49));
        infoPanel.setPreferredSize(new java.awt.Dimension(28000, 10000));

        javax.swing.GroupLayout infoPanelLayout = new javax.swing.GroupLayout(infoPanel);
        infoPanel.setLayout(infoPanelLayout);
        infoPanelLayout.setHorizontalGroup(
            infoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 28000, Short.MAX_VALUE)
        );
        infoPanelLayout.setVerticalGroup(
            infoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 10000, Short.MAX_VALUE)
        );

        jScrollPane2.setViewportView(infoPanel);

        jPanel4.setBackground(new java.awt.Color(255, 255, 51));

        region_info.setText("region info");
        region_info.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                region_infoActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
        jPanel4.setLayout(jPanel4Layout);
        jPanel4Layout.setHorizontalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel4Layout.createSequentialGroup()
                .addContainerGap(51, Short.MAX_VALUE)
                .addComponent(region_info, javax.swing.GroupLayout.PREFERRED_SIZE, 93, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(43, 43, 43))
        );
        jPanel4Layout.setVerticalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addGap(67, 67, 67)
                .addComponent(region_info, javax.swing.GroupLayout.PREFERRED_SIZE, 41, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(678, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel3Layout.createSequentialGroup()
                .addContainerGap(200, Short.MAX_VALUE)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 1011, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
            .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(jPanel3Layout.createSequentialGroup()
                    .addComponent(jPanel4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 1034, Short.MAX_VALUE)))
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 693, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(104, Short.MAX_VALUE))
            .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(jPanel3Layout.createSequentialGroup()
                    .addContainerGap()
                    .addComponent(jPanel4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addContainerGap()))
        );

        nodeTab.addTab("info", jPanel3);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(nodeTab, javax.swing.GroupLayout.DEFAULT_SIZE, 1226, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(3, 3, 3)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(nodeTab, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void manetActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_manetActionPerformed
        // TODO add your handling code here:
        stop=0;
        c=0;
        infoFlag=0;
        linkFlag=0;
        manetFlag=1;
        clear=0;
        String siparticleNo=size.getText();
        try{
        iparticleNo = Integer.parseInt(size.getText());
        }
        catch(NumberFormatException ex)
        {
            System.out.println("Number format exception"+ex.getMessage());
            JOptionPane.showMessageDialog (null, "Only Integer Number between 2 to 8192 allowed", "Number format error ", JOptionPane.ERROR_MESSAGE);
            return;
        }
        s=iparticleNo;
        g=design.getGraphics();
        if(s>8192)
        { 
            JOptionPane.showMessageDialog (null, "Number of nodes exceeding 8192. Please Enter Lesser no", "INPUT ERROR", JOptionPane.ERROR_MESSAGE);
            return;
        }
        if(s<2)
        { 
            JOptionPane.showMessageDialog (null, "Number of nodes Less than 2. Please Enter Larger no", "INPUT ERROR", JOptionPane.ERROR_MESSAGE);
            return;
        }   
        
        new Thread(
            new Runnable() {
                public void run() {
                    nodeRepaint();
                }
            }
        ).start();
        // set all links to 0
        for(int u=1;u<=s;u++)
        {
            for(int v=1;v<=s;v++)
           {
              link[u][v]=0;
           }
        }
    }//GEN-LAST:event_manetActionPerformed

    private void show_hideActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_show_hideActionPerformed
// TODO add your handling code here:
        if(infoFlag!=1)
       {if(showNodes==0)
       {
          showNodes=1;
          show_hide.setText("Hide");
       } else
       {
           showNodes=0;
           show_hide.setText("Show");
       }
          /////////////////////////////////
        
            if (showNodes==1)
            {
               g=design.getGraphics();
                for(int i=0;i<nodecounter;i++)
                {
                   g.drawString(""+(i+1),XArray[i],(YArray[i]+14)) ;
                   
                }
            }
            if(showNodes==0)
            {
                g=design.getGraphics();
                for(int i=0;i<nodecounter;i++)
                {
                g.setColor(Color.yellow);
                g.fillOval(XArray[i],YArray[i], 20, 17);
                }
            }
            
        
        
       }
    }//GEN-LAST:event_show_hideActionPerformed

    private void region_infoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_region_infoActionPerformed
        // TODO add your handling code here:
        
        
     
        
        
          g1=infoPanel.getGraphics();
          
        stop=1;
        infoFlag=1;
         c=0;
         
       // stop=1;
      
        g1.setColor(Color.blue);
        g1.drawString("......The region information......",400,20);
        
        int m=50,n=50;

        int j=0;
        for(int i=0;i<nodecounter;i++)
        {
            if(i%8==0)
            {
                n+=10;
                g1.setColor(Color.red);
                 g1.drawString("Region :"+((i/8)+1)+" pat="+regionNumber[c] ,m,n );
                
                 c++;
                n+=16;
            }
            
            g1.setColor(Color.green);
            g1.drawString("node"+(i+1)+"   x="+XArray[i]+ "  y="+YArray[i],m,n);
            g1.setColor(Color.white);
            
            for(int b=1;b<=s;b++)
            {    
               if(link[i+1][b]>=1)
                {
                g1.drawString("--> "+(b)+"  "+link[i+1][b],m,n+14);
                n+=14;
                }
            }    
            n+=30;
            j++;

            if(j%64==0)
            {  m+=180;
                n=50;
            }

        }
//         for(int k=1;k<=c;k++)
//                    for(int q=0;q<6;q++)
//                         g1.drawString(""+nebr[k][q],m+150,(n+k*10));
//                         m=m+50;
//          
 //              writing output in a file
         {
            try 
            {
                BufferedWriter bw;
                bw = new BufferedWriter(new FileWriter("op"+s+".txt",true));
               
                 c=0;
                
                for(int i=0;i<nodecounter;i++)
                {
                     if(i%8==0)
                    {
                        n+=10;
                        bw.newLine();
                        bw.write("Region :"+((i/8)+1)+" pat="+regionNumber[c] );
                
                        c++;
                        n+=16;
                    }
                    bw.write(" \n ");
                }
//            g1.setColor(Color.black);
//            g1.drawString("node"+(i+1)+"   x="+XArray[i]+ "  y="+YArray[i],m,n);
//            n+=14;
//            j++;
//
//            if(j%200==0)
//            {  m+=180;
//                n=50;
//            }
 
                bw.close();
            } 
            catch (IOException ex) 
            {
                Logger.getLogger(frmMain.class.getName()).log(Level.SEVERE, null, ex);
            }
         }
         
        jScrollPane2.revalidate();
        
    }//GEN-LAST:event_region_infoActionPerformed

    private void stopMovementActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_stopMovementActionPerformed
        // TODO add your handling code here:
           stop=1; 
    }//GEN-LAST:event_stopMovementActionPerformed

    private void destActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_destActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_destActionPerformed

    private void routeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_routeActionPerformed
        // TODO add your handling code here:
        stop=1;
        linkFlag=1;
        try{
            if(manetFlag!=1)
            {
                throw new Exception();
                
            }
        }
        catch(Exception e)
        {
            JOptionPane.showMessageDialog (null, "First Press Enter then Press link", "Procedure format error ", JOptionPane.ERROR_MESSAGE);
            return;
        }
        g=design.getGraphics();
//       int a = Integer.parseInt(source.getText());
//       linking(a);
        double time2;
        double time1 = System.currentTimeMillis();
        
        for(int u=1;u<=s;u++)
        {
            for(int v=1;v<=s;v++)
           {
              link[u][v]=0;
           }
        }
        for(int w=1;w<=s;w++)
        {
            if((w)%8==1)
            {
            linkingRep(w);
            }
            else
            linking(w);
        }
        
        System.out.println("linking done");
        time2 = System.currentTimeMillis();
        System.out.println("time elapsed = "+(time2-time1));
        
       
        
        
    }//GEN-LAST:event_routeActionPerformed

    private void sizeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sizeActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_sizeActionPerformed

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        // TODO add your handling code here:
        s=iparticleNo=c=0;
        stop=1;
        clear=1;
        int a=0;
        while(a<100)
        {
            path[a]=0;
            a++;
        }
        for(int i=0;i<8192;i++)
        { 
            for(int j=0;j<8192;j++)
            {    
                forPath[i][j]=0;
                forCost[i][j]=0;
                
            }   
            for(int j=0;j<1000;j++)
            {    
            foragingZone[i][j]=0;
            foragingReg[i][j]=0;
            }
        }
        repaint();
        
    }//GEN-LAST:event_jButton2ActionPerformed

    private void sendActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sendActionPerformed
        // TODO add your handling code here:
        try
        {
            
            if(linkFlag!=1)
                throw new Exception();
            
            if((source.getText())==null || dest.getText()==null)
            {
                throw new NumberFormatException();
            }
        }
        catch(NumberFormatException ec)
        {
            JOptionPane.showMessageDialog (null, "Please Enter the source and destination", "Procedure format error ", JOptionPane.ERROR_MESSAGE);
            System.out.println("Empty source or dest");
            return;
        
        }
        catch(Exception e)
        {
            JOptionPane.showMessageDialog (null, "Linking Not Done. First link then press send", "Procedure format error ", JOptionPane.ERROR_MESSAGE);
            return;
        }
        
        int a=0;
        int node;
        int src;
        int des;
        search=0;
        double time2;
        double time;
        double time1;
        found=0;
        time = System.currentTimeMillis();        
        time1 = System.currentTimeMillis();
        //Now calculating forzone of each function.... i.e nodes within 2 hops
        
        for(node=1;node<=s;node++)
        {    
            forgZ=node;
            forZone1(node);
        }
        
        time2 = System.currentTimeMillis();
        
        System.out.println("Forzone  done");
        System.out.println("time taken:"+(time2-time1)+" time1= "+time1+"  time2 = "+time2);
        //to check foraging zone of each node
        /*
        for(node=1;node<=s;node++)
        {   
            a=0;
            while(foragingZone[node][a]>0)
            {    
               System.out.println("ForZone of "+node+": "+foragingZone[node][a]);
                a++;
            }
            
        }
        */
        
        
        for(node=1;node<=s;node=node+8)
        {
           forRegion(node);
        }
       
        System.out.println("Foraging region done");
        
        
        
      //  System.out.println("ForZone of "+node+": "+foragingZone[node][a]);
        
        
        // shortest path
        
        try{
        src= Integer.parseInt(source.getText());
            if(src<1 || src>s)
            {
                throw new NumberFormatException();
            }
        }
        catch(NumberFormatException ex)
        {
            System.out.println("Number format exception"+ex.getMessage());
            JOptionPane.showMessageDialog (null, "Please Enter Source node number between 1 to "+s, "Number format error ", JOptionPane.ERROR_MESSAGE);
            return;
        }
        
        try{
        des= Integer.parseInt(dest.getText());
            if(des<1 || des>s)
            {
                throw new NumberFormatException();
            }
        }
        
        catch(NumberFormatException ex)
        {
            System.out.println("Number format exception"+ex.getMessage());
            JOptionPane.showMessageDialog (null, "Please Enter Destinaton node number between 1 to "+s, "Number format error ", JOptionPane.ERROR_MESSAGE);
            return;
        }
        srcG=src;
        desG=des;
        
       int temp;
       int temp1=0;
       int tempRep;
       int max=0;
       int visitedMax=0;
       double cost=0;
       double costDelay=0;
       int newSrc=0;
       double time3;
       int repBand=0;
       int repFlag=0;
       hopCount=0;
       a=0;
       
       time3 = System.currentTimeMillis();
                      
                     
        
       //STep 1
       //check within its own foraging zone
       while(foragingZone[src][a]>0)
       { 
           
           if(des==foragingZone[src][a])
           {
               System.out.println("found in FZONE of source");
              
               if(link[src][des]!=0)
               {    
                path[hopCount]=forPath[src][des];
                hopCount++;
               }        
             
                        
               // System.out.println("fpath    --------------------------------    added for"+src+"to"+des+" "+forPath[src][des]);
                       
                        
               found=1;
               System.out.println("Path is "+src+"--->"+forPath[src][des]+"--->"+des);
           }
           a++;
           
       }
       if(found!=1)
       {    
       System.out.println("Foraging zone check of source done");
       }
       
       //check for dest in the foraging Zone of representatitve nodes connected to the representative node of the source
       if(src%8!=0)
       {
           tempRep=(src/8)*8+1;
       }
       else
       {
           tempRep=((src/8)-1)*8+1;
       }
        if((des%8)!=0)
       {   
           des=(des/8)*8 +1 ;
       }else
       { 
           des=((des/8)-1)*8 +1 ;
       }
       a=0;
                                            
       //   hopCount++; // ???????????????????????????????
          
          if(found!=1)
       {    
      
          path[hopCount]=tempRep;
           hopCount++;
       }
          
          
          while((foragingReg[tempRep][a]>0)&& (found!=1))
       {
           System.out.println("forg node are="+foragingReg[tempRep][a]);
           temp=foragingReg[tempRep][a];
           System.out.println("tempRep===="+tempRep);
           temp1=0;
           
                    while(foragingZone[temp][temp1]>0 && (found!=1))
                    {
                         //System.out.println("forzone of "+foragingReg[tempRep][a]+" :"+foragingZone[temp][temp1]);
                         if(des==foragingZone[temp][temp1])
                         {    
                             System.out.println("found in FZONE of "+temp);

                             path[hopCount]=temp;                                      
                             hopCount++;
                             if(link[temp][des]==0)
                             {
                                 path[hopCount]=forPath[temp][des];
                                 hopCount++;
                                     
                             }

                             found=1;

//
//                                  path[hopCount]=forPath[temp][des];
//                                 hopCount++;
                                 
//                                 for(int i=0;i<6;i++)
//                                 System.out.println("fpath    --------------------------------                           added for"+temp+"to"+des+" "+forPath[temp][des]);


                         }
                         temp1++;
                    }
           a++;
           
       }
          if(found!=1)
       {
       System.out.println("Foraging zone of foraging region of source check done");
       }
          
          
          
          //////////////// SQUARE SEARCH
          
          if(found!=1)
       {    
       
       
       System.out.println("Starting square search");
       
       
       
       //starting square search
       if((src%8)!=0)
       {
           src=(src/8)*8 +1 ;
       }
       else
       {   
           src=((src/8)-1)*8 +1 ;
       }
       
       if((des%8)!=0)
       {   
           des=(des/8)*8 +1 ;
       }else
       { 
           des=((des/8)-1)*8 +1 ;
       }
       
       hopCount=0;
        path[hopCount]=src;  // rep of srcG
            hopCount++;
       
       while(found!=1 && (src!=0))
       {
           a=0;
           max=0;
           System.out.println("searching"+src+" "+des);
           search(src,des);
           
           repFlag=0;
           if(router[a]==0)
           {
               noRouteFlag=1;
               search(src,des);
               noRouteFlag=0;
           }
            while(router[a]>0) 
            {
//                System.out.println("router ="+router[a]);
//                System.out.println("link out.....="+link[src][router[a]]);
//                if(( link[src][router[a]])==0)
//                {
//                   // repBand=forPath[src][router[a]][1];
//                    if(router[a]%8==1)
//                    {
//                      repFlag=1;                          
//                        
//                    }
//                }
                if(delayFlag==0)
                {
                        if(( link[src][router[a]]) >= max  )
                    {

                        visitedMax=0;
                        for(int i=0;i<hopCount;i++)
                         {
                            if(path[i]==router[a])
                            {
                                    visitedMax=1;  
                            }
                         } 
                              
                        
                        if(visitedMax!=1)
                        { //System.out.println("Max changed to="+link[src][router[a]]);
                        max=link[src][router[a]];
                        newSrc=router[a];
                        }
                    }
                }
                else
                {
                        if(( link[src][router[a]]) >= max && (forCost[src][router[a]] <=4) )
                    {

                              visitedMax=0;
                              for(int i=0;i<hopCount;i++)
                              {
                                   if(path[i]==router[a])
                                   {
                                       visitedMax=1;  
                                   }
                              } 
                              
                        
                            if(visitedMax!=1)
                             { 
                               // System.out.println("Max changed to="+link[src][router[a]]);
                                max=link[src][router[a]];
                                newSrc=router[a];
                            }

                    }
                
                }
                
                a++;
                
            } 
//            if(max<11)
//            { 
//                a=0;
//                while(router[a]>0) 
//                {
//                   // System.out.println("router ="+router[a]);
//                   // System.out.println("link out.....="+link[src][router[a]]);
//                    if(router[a]%8==1)
//                    {
//                        repBand=forPath[src][router[a]][1];
//                        if(( link[src][router[a]]) >= max )
//                        {
//                            System.out.println("INSIDE REP BAND...!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
//                           // System.out.println("Max changed to="+link[src][router[a]]);
//                            path[hopCount]=forPath[src][newSrc][1];
//                             newSrc=router[a];
//                             hopCount++;
//                        }
//                    }
//                
//                    a++;
//                }
//            
//            }
            
            if(a==0)
            {
                System.out.println("No Route found");
                break;
            }
            repFlag=0;
            //incase no long routes  are present
            if((max==0) && (found!=1))
            {
                int rand=(int)(Math.random() * (a));
                System.out.println("Choosing random");
                a=0;
                while(router[a]>0)
                {
                    if(router[a]%8==1)
                    {
                        newSrc=router[rand];
                        repFlag=1;
                    }
                    a++;
                }
                if(repFlag==0){
                newSrc=router[rand];
                }
                else
                {
                rand=(int)(Math.random() * (a));
                newSrc=router[rand];
                }
            }
            //for prevention of node being visited again
            for(int i=0;i<hopCount;i++)
            {
                if(path[i]==newSrc)
                {
                    System.out.println("Path visited");
                    int rand=(int)(Math.random() * (a));
                     newSrc=router[rand];
                }
            }
            
            //indirect links with bandwith 0
                     if(link[src][newSrc]==0 && found!=1)
                    { 
                        System.out.println("fpath    --------------------------------                           added for"+src+"to"+newSrc+" "+forPath[src][newSrc]);
                        try
                        {
                         path[hopCount]=forPath[src][newSrc];
                         System.out.println("Bandwith of via path="+link[src][forPath[src][newSrc]] +" && " +link[forPath[src][newSrc]][newSrc]);
//                        for(int i=0;i<10;i++)
//                        System.out.println("fpath    --------------------------------                           added for"+src+"to"+newSrc+" "+forPath[src][newSrc]);
                        
                        hopCount++;
                        
                        
                        }
                        catch(Exception e)
                        {
                            System.out.println("....."+e.getMessage());
                        }
                     }
            if (found!=1)
            {    
            System.out.println("Next Hop is"+newSrc+"  Bandwith="+link[src][newSrc]); 
            }
            try
            {    
                cost+=(float)(1000000/((link[src][newSrc]*2)+1));
                costDelay+=(float)(forCost[src][newSrc]);
                System.out.println(""+forCost[src][newSrc]);
           // System.out.println("time elapsed till next hop= "+cost/10000000.000000); //assuming packet size of 0.5
           // System.out.println("time elapsed (  **if delay included ** ) tillnext hop= "+((cost/10000000.000000)+costDelay)); 
            }
            catch(Exception e)
            {
                System.out.println(""+e.getMessage());
            }
            
            
            src=newSrc;
            if(found!=1)
            {
            path[hopCount]=newSrc;
            hopCount++;
            }
         }
       }
       
       
       if(found==1)
       {
            path[hopCount]=des;
            hopCount++;
            String str="";
           System.out.println("Found in "+(hopCount+1)+"hops");
           System.out.print("path is:   "+srcG);
           str+=""+srcG+"---> ";
           if(srcG%8!=1)
           {
               if(srcG%8!=0)
               {    
               System.out.print("--->"+(((srcG/8)*8)+1));
               str+=""+(((srcG/8)*8)+1)+"---> ";
               }
               else
               {
                   System.out.print("--->"+((((srcG/8)-1)*8)+1));
                   str+=""+((((srcG/8)-1)*8)+1)+"---> ";
               }   
           }
           for(int i=1;i<hopCount;i++)
           {
               System.out.print("--->"+path[i]);
               str+=""+path[i]+"--->";
           }
            
           System.out.println("--->"+desG);
           str+=""+desG+"";
           g.setColor(Color.YELLOW);
           
           JOptionPane.showMessageDialog (null, "Found in "+(hopCount+1)+" hops"+System.lineSeparator()+"The Path is "+str, "Path info ", JOptionPane.INFORMATION_MESSAGE);
           
            if(stop==1 && showNodes==1)
                    
                {
                    int x1=0,y1=0,hgt=0,wdt=0,col1=10,col2=10,opacity=30;
                    
                    for(int i=1;i<=search;i++)
                    {
                        g.setColor(new Color(col1,col2,50,opacity));
                        x1=(int) searchSquare[i][1];
                        y1=(int) searchSquare[i][2];
                        hgt=(int) searchSquare[i][3];
                        wdt=(int) searchSquare[i][4];
                        g.fillRect(x1,y1,hgt,wdt);
                       // col1+=30;
                       // col2+=30;
                       // opacity+=10;
                    } 
                }
                
                
                if (stop==1 && clear!=1)
               {
                   
                 int drawx1;
                int drawx2;
                int drawy1;
                int drawy2;
                for(int i=0;i<hopCount-1;i++)
           {
               if(path[i]==0)
                   System.out.println("path[i]= zero"+i);
               else
               { 
               try{    
                    drawx1=XArray[path[i]-1];
                    drawy1=YArray[path[i]-1];

                    drawx2=XArray[path[i+1]-1];
                    drawy2=YArray[path[i+1]-1];
                      g.setColor(Color.BLUE);
                     g.fillOval(drawx1, drawy1, 20, 17);
                     g.fillOval(drawx2, drawy2, 20, 17);

                    g.setColor(Color.RED);
                    g.drawLine(drawx1+10,drawy1+10,drawx2+10,drawy2+10);
                    g.drawString(""+path[i],drawx1, drawy1);
                    }
             
                     catch(Exception e){}
               
               }
             }
          }
       }else
           System.out.println("node not found");
           
       
       
       
        time2 = System.currentTimeMillis();
                      
        System.out.println("total time elapsed in search="+(time2-time3)+"mili sec" );              
        System.out.println("total time elapsed="+(time2-time)+"mili sec" );
        
        
        
        
        
        
        
        
        
    }//GEN-LAST:event_sendActionPerformed

    private void delayToggleActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_delayToggleActionPerformed
        // TODO add your handling code here:
        if(delayFlag==1)
        {
            delayFlag=0;
            delayToggle.setText("Turn Delay ON");
        }
        else
        {
            delayFlag=1;
            delayToggle.setText("Turn Delay OFF");
        }
    }//GEN-LAST:event_delayToggleActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(frmMain.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(frmMain.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(frmMain.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(frmMain.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new frmMain().setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton delayToggle;
    /*
    private javax.swing.JPanel design;
    */ myPanel design;
    private javax.swing.JTextField dest;
    /*
    private javax.swing.JPanel infoPanel;
    */ myInfoPanel infoPanel;
    private javax.swing.JButton jButton2;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JButton manet;
    private javax.swing.JTabbedPane nodeTab;
    private javax.swing.JButton region_info;
    private javax.swing.JButton route;
    private javax.swing.JButton send;
    private javax.swing.JButton show_hide;
    private javax.swing.JTextField size;
    private javax.swing.JTextField source;
    private javax.swing.JButton stopMovement;
    // End of variables declaration//GEN-END:variables
///// new functions n vars
    static int s;
    int h;//count of nebr fr a perticular region
    int p;//used for loop for calculating region
    int rc;//region count secondry variable
    Graphics g;
    Graphics g1;// graphics used for info panel
    int iparticleNo;
    int counter = 0;
    int hexCounter[][];
    int nodecounter = 0;
    int pattern = 0;
    int region;
    int regSqrt;
    int extReg;
    int toggle=0;
    int building=0;
    ///
    int nebrFlag=0;
    int XArray[] = new int[10000]; //x co rdinate for nodes
    int YArray[] = new int[10000];
    int Xhex[]=new int[15000];// x cordinate for region
    int Yhex[]=new int[15000];  
    int repaintcounter = 0;
    int infoFlag = 0;
    
    int regionNumber[]=new int[10000] ;
    int showNodes = 0;      //to show hide the node no.
    int stop = 0;       // to stop the movement
    int c=0;
    long nebr[][]=new long[3600][3600]; // neighbour of rgions
    static int link[][]=new int[9000][9000];      //links between nodes a-b
    static int foragingZone[][]=new int[9000][1000];
    static int forgZCount=0;
    static int forgZ=1;
    static float forCost[][]=new float[9000][9000];
    
    int clear=0;
    int srcG;
    int desG;
    
    int router[]=new int[500];
    int found=0;
    
    int foragingReg[][]=new int[9000][1000];
    static int forgRCount=0;
    
    int hopCount=0;
    int path[]=new int [1000];
    static int forPath[][]=new int[9000][9000];
    
   int delay[][]=new int[9000][9000];
   int delayFlag=0;
   
   
   float searchSquare[][]=new float[100][10];
   int search=0;
   
   int manetFlag=0;
   int linkFlag=0;
   
   int noRouteFlag=0;
   
    public class myInfoPanel extends JPanel
    {
    public myInfoPanel() {
        }
    @Override
    protected void paintComponent(Graphics gr1)
    {
        super.paintComponent(gr1);
           
        Graphics g1;
        g1=gr1;
        g1=infoPanel.getGraphics();
          
        
        infoFlag=1;
        c=0;
       // stop=1;
        g1.setColor(Color.blue);
        g1.drawString("......The region information......",400,20);
        
        int m=50,n=50;

        int j=0;
        for(int i=0;i<nodecounter;i++)
        {
            if(i%8==0)
            {
                n+=10;
                g1.setColor(Color.red);
                //g1.drawString("Region :"+((i/8)+1)+regionNumber[c] ,m,n );
                g1.drawString("Region :"+((i/8)+1)+" pat="+regionNumber[c] ,m,n );
                 
                c++;
                n+=16;
            }
            
            g1.setColor(Color.green);
            g1.drawString("node"+(i+1)+"   x="+XArray[i]+ "  y="+YArray[i],m,n);
            g1.setColor(Color.white);
            
            //link info
            for(int b=1;b<=s;b++)
            {    
                if(link[i+1][b]>=1)
                {
                g1.drawString("--> "+(b)+"  "+link[i+1][b],m,n+14);
                n+=14;
                }
 
            }
            n+=30;
            j++;

            //limit of vertical info
            if(j%64==0)
            {  m+=180;
                n=50;
            }

        }
//        for(int k=1;k<=c;k++)
//                    for(int q=0;q<6;q++)
//                         g1.drawString(""+nebr[k][q],m+150,(n+k*10));
//                         m=m+50;
         
        
    }
    
    }
    public class myPanel extends JPanel {

        public myPanel() {
        }

        @Override
        protected void paintComponent(Graphics gr) {
          //  if(stop!=1)
            {
                
            super.paintComponent(gr);
            g=gr;
//            if (stop==1)
//                return;
                      // info panel is not being displayed
            repaintcounter++;
            counter = 0;
            
            
            nodecounter = 0;
            int x, y, z;
            int count = 0;
            c=0;
               
            s = iparticleNo;
            region=s/8;
            
            if(s%32==0)
            {    if(stop!=1)
                {    
                pattern++;
                }
            }
            
            regSqrt=(int) Math.sqrt(region);  //matrix regSqrt X regSqrt
            
            if(s%8!=0)
            {
                extReg=(region-(regSqrt*regSqrt))+1;
                
            }
            else
            {    
                extReg=(region-(regSqrt*regSqrt));
            }   
            
       //     g.drawString(""+regSqrt,10,10);
            //if( s>220)
            //{
            //   g.drawString("ENTER STRING LESS THAN 220",400,400);
            //    return;
// }

            /*
             for(int i=0;i<(s/2);i++)
             {
    
             drawRegion(x,y,z);
 
             y+=90;
             z+=90;
             }
             x=30;y=50;z=50;
             for(int i=0;i<(s/2);i++)
             {
             x+=90;
             z+=90; 
             drawRegion(x,y,z);
 
 
 
             }*/


//drawing set of 4 regions each in 4 rows...
//it first draws horizontaly then goes next loop for new row 
           
            int oddCount=0;
            int tempX=0;
            int tempY=0;
        
            //drawing MATRIX OF N X N RegSqrT
              
                 x = 100;
                 y = 100;
                for(int j = 0; j < regSqrt; j++ )       //for drawing matrix
                {    
                    
                    for (int i = 0; i < regSqrt; i++)
                    {

                             DrawHexagon(x, y);
                             DrawNodes(x, y);
                            
                             
                             x += 174;
                             count++;
                    }
                    
                    oddCount++;
                    
                        if(oddCount%2==1)      //setting co ordinate of initial region in a row 
                        {    
                             y+=150;
                             x=187;
                        }
                        else
                        {
                            y+=150;
                            x=100;
                        }    
                }
                
                
                
                
                
                oddCount=0; 
                 x = ((regSqrt) * 174) + 100;
                    y = 100;
                if(extReg<regSqrt)          // for Drawing only in last coloumn
                {
                         for(int j = 0; j < extReg;j++ )
                         {    
                                 
                             DrawHexagon(x,y);
                             DrawNodes(x,y);
                             
                                oddCount++;
                    
                                if(oddCount%2==1)
                                {    
                                    y+=150;
                                     x+=87;
                                }
                                else
                                {
                                    y+=150;
                                    x-=87;
                                }                
                                            
                                             
                         }
                         
                 }
                
                else
                {    
                    for(int j = 0; j < regSqrt;j++ )
                         {    
                                 
                             DrawHexagon(x,y);
                             DrawNodes(x,y);
                             
                                oddCount++;
                    
                                if(oddCount%2==1)
                                {    
                                    y+=150;
                                     x+=87;
                                }
                                else
                                {
                                    y+=150;
                                    x-=87;
                                }                
                                            
                                             
                         }
                    
                    
                    
                    
                    
                        
                        y = ((regSqrt) * 150) + 100;
                        if(regSqrt%2==1)
                        {
                            x=187;
                        }
                        else
                        {   
                            x=100;
                        }
                        
                     for(int j = 0; j < extReg-regSqrt;j++ )
                     {    
                       DrawHexagon(x,y);
                       DrawNodes(x,y);
                             
                            x+=174;
                         
                     }
                
                }
            
//            x = 100;
//            y = 400;
//            for (int i = 0; i < regSqrt; i++) {
//                DrawHexagon(x, y);
//                DrawNodes(x, y);
//                x += 174;
//            }
//            x = 187;
//            y = 550;
//            for (int i = 0; i < s / 32; i++) {
//                DrawHexagon(x, y);
//                DrawNodes(x, y);
//                x += 174;
//            }
             //   g.drawString(""+repaintcounter,200,500);
                
                
                if(stop==1 && showNodes==1 && clear!=1)
                    
                {
                    int x1=0,y1=0,hgt=0,wdt=0,col1=10,col2=10,opacity=30;
                    
                    for(int i=1;i<=search;i++)
                    {
                        g.setColor(new Color(col1,col2,50,opacity));
                        x1=(int) searchSquare[i][1];
                        y1=(int) searchSquare[i][2];
                        hgt=(int) searchSquare[i][3];
                        wdt=(int) searchSquare[i][4];
                        g.fillRect(x1,y1,hgt,wdt);
                       // col1+=30;
                       // col2+=30;
                       // opacity+=10;
                    } 
                }
                
                
                if (stop==1 && clear!=1)
               {
                   
                 int drawx1;
                int drawx2;
                int drawy1;
                int drawy2;
                    try
                    {    
                    drawx1=XArray[srcG-1];
                    drawy1=YArray[srcG-1];
                
                    drawx2=XArray[path[0]-1];
                    drawy2=YArray[path[0]-1];
                    
                    g.setColor(Color.BLUE);
                    g.fillOval(drawx1, drawy1, 20, 17);
                    g.drawString(""+srcG,drawx1,drawy1);
                     g.fillOval(drawx2, drawy2, 20, 17);
                     g.setColor(Color.RED);
                     g.drawLine(drawx1+10,drawy1+10,drawx2+10,drawy2+10);
                    }
                    catch(Exception e){}
                    int lstSrcx1=0;
                    int lstSrcy1=0;
                for(int i=0;i<hopCount-1;i++)
           {
               if(path[i]==0)
               {   
                   System.out.println("path[i]= zero "+i);
                   drawx1=XArray[path[0]-1];
                    drawy1=YArray[path[0]-1];
                     g.setColor(Color.BLUE);
                    g.fillOval(drawx1, drawy1, 20, 17);
                    drawx2=XArray[desG-1];
                    drawy2=YArray[desG-1];
                    g.setColor(Color.RED);
                    g.drawLine(drawx1+10,drawy1+10,drawx2+10,drawy2+10);
               }
               else
               { 
               try{    
                    drawx1=XArray[path[i]-1];
                    drawy1=YArray[path[i]-1];

                   lstSrcx1= drawx2=XArray[path[i+1]-1];
                   lstSrcy1= drawy2=YArray[path[i+1]-1];
                      g.setColor(Color.BLUE);
                     g.fillOval(drawx1, drawy1, 20, 17);
                     g.fillOval(drawx2, drawy2, 20, 17);

                    g.setColor(Color.RED);
                    g.drawLine(drawx1+10,drawy1+10,drawx2+10,drawy2+10);
                    g.drawString(""+path[i],drawx1, drawy1);
                    }
               catch(Exception e){}
                }
             }
                
                  try{
                    drawx1=XArray[path[search]-1];
                    drawy1=YArray[path[search]-1];
      //                System.out.println("lst line" +path[search]);
                      drawx1=XArray[path[hopCount-1]-1];
                    drawy1=YArray[path[hopCount-1]-1];
                    drawx2=XArray[desG-1];
                    drawy2=YArray[desG-1];
                    g.setColor(Color.blue);
                    g.fillOval(drawx2, drawy2, 20, 17);
                    g.setColor(Color.RED);
                    g.drawLine(drawx1+10,drawy1+10,drawx2+10,drawy2+10);
                    if(lstSrcx1!=0)
                    {    
                   g.drawLine(lstSrcx1+10,lstSrcy1+10,drawx2+10,drawy2+10);
                    }
                  }
                  catch(Exception e){}
                  
             
                
                
                
                
                                
           
           }
            /*extra nodes*/
//for regions where nodes exceeding multiple of 32 nodes 0+ 32+ 64+ ......
//            int t = s % 32;
//            int p;
//            if (t != 0) //t is not zeroTh 32nd 64th ..... node
//            {
//                if (t % 8 != 0) //t%8 is not zero i.e. not the 0 ,8th 16th 24th node...  
//                {
//                    p = (t / 8) + 1;
//                } //gives the value from 0-3 and adding 1 gives 1-4 showing how many regions to add 
//                // for 1-7 gives 1 9-15 gives 2 ....and so on
//                else {
//                    p = t / 8;
//                }       // for 8th 16th 24th node gives 1,2,3.
//            } else {
//                p = t / 8; //for zero 32 64 nodes gives zero.
//                pattern++;
//            }
//
//
//
//
//            switch (p) {
//
//                //case 1 gives 1 region for next 8 nodes after multiple of 32
//                case 1:
//                    x = (count * 174) + 100;
//                    y = 100; {
//                    DrawHexagon(x, y);
//                    DrawXNode(x, y);
//                    x += 174;
//                    pattern++;
//                }
//                break;
//
//
//                case 2:    //drawing 2 regions for next 16 nodes after multiple of 32.
//                    x = (count * 174) + 100;
//                    y = 100; {
//                    DrawHexagon(x, y);
//                    DrawNodes(x, y);
//                    x += 174;
//                }
//
//
//
//                x = (count * 174) + 187;
//                y = 250; {
//                    DrawHexagon(x, y);
//                    DrawXNode(x, y);
//                    x += 174;
//                }
//                break;
//
//                case 3:   //drawing 3 regions for next 24 nodes after multiple of 32.
//                    x = (count * 174) + 100;
//                    y = 100; {
//                    DrawHexagon(x, y);
//                    DrawNodes(x, y);
//                    x += 174;
//                }
//
//
//
//                x = (count * 174) + 187;
//                y = 250; {
//                    DrawHexagon(x, y);
//                    DrawNodes(x, y);
//                    x += 174;
//                }
//
//
//                x = (count * 174) + 100;
//                y = 400; {
//                    DrawHexagon(x, y);
//                    DrawXNode(x, y);
//                    x += 174;
//                    pattern++;
//                }
//                break;
//
//
//                case 4: //drawing 4 regions
//
//                    x = (count * 174) + 100;
//                    y = 100; {
//                    DrawHexagon(x, y);
//                    DrawNodes(x, y);
//                    x += 174;
//                }
//
//
//
//                x = (count * 174) + 187;
//                y = 250; {
//                    DrawHexagon(x, y);
//                    DrawNodes(x, y);
//                    x += 174;
//                }
//
//
//
//                x = (count * 174) + 100;
//                y = 400; {
//                    DrawHexagon(x, y);
//                    DrawNodes(x, y);
//                    x += 174;
//                }
//
//
//
//                x = (count * 174) + 187;
//                y = 550; {
//                    DrawHexagon(x, y);
//                    DrawXNode(x, y);
//                    x += 174;
//
//                }
//                break;
//
//
//                default:
//                    break;
//
//            }
//            
            
           
            /*

             int m=100,n=500;

             int j=0;
             for(int i=0;i<nodecounter;i++)
             {  
             g.drawString("node"+(i+1)+"  x="+XArray[i],m,n);
             g.drawString("y="+YArray[i],m+150,n);
             n+=14;
             j++;p
             if(j%30==0)
             {  m+=300;
             n=500;
             }
    
             }
             g.drawString("repaint paint counter =" +repaintcounter,500,300);

             */
           

         }// info flag 
            
//            if(nebrFlag<8) //finds neighbour uptill 8 iteration of threads then uses the same info as it does not changes
//            {   
//                    for(p=0;p<c;p++)
//                    {
//                            findNebr(Xhex[p] ,Yhex[p]);
//                    }
//          
//            }
//             nebrFlag++;
          
        }
        
        
        
    }

    void DrawNCounter(int x, int y) //x y here is not the center but the cordinates of the nodes..
    {
        XArray[nodecounter] = x;
        YArray[nodecounter] = y;

        g.setColor(Color.yellow);
        g.fillOval(x, y, 20, 17);
        nodecounter++;
        if (showNodes == 1) 
        {
            g.setColor(Color.black);
            g.drawString("" + nodecounter, x, y + 14);
        }
    }

    void DrawNodes(int x, int y) {
        // pattern+=5;
              
        
            
            
            
        pattern %= 4;
       // hexCounter[counter][1]=pattern;
        //pattern 1
        if(counter==(region+1) && (s%8)!=0)
        {
            DrawXNode(x,y);
                
        }
        else if (pattern == 0) {
            DrawNCounter(x - 40, y - 40);

            DrawNCounter(x + 30, y - 40);

            DrawNCounter(x - 40, y + 40);

            DrawNCounter(x + 40, y + 40);

            DrawNCounter(x - 5, y - 80);

            DrawNCounter(x - 5, y + 75);

            DrawNCounter(x + 60, y);

            DrawNCounter(x - 70, y);
            if(stop!=1)
            {
                pattern++;
            }
        } else if (pattern == 1) {

            DrawNCounter(x, y - 80);
            DrawNCounter(x - 65, y - 45);
            DrawNCounter(x - 70, y + 30);
            DrawNCounter(x, y + 70);
            DrawNCounter(x + 60, y - 45);
            DrawNCounter(x + 50, y + 45);
            DrawNCounter(x + 15, y - 45);
            DrawNCounter(x - 25, y + 25);
            
            if(stop!=1)
            {
                pattern++;
            }
            
        } else if (pattern == 2) {
            DrawNCounter(x - 8, y - 90);
            DrawNCounter(x - 65, y - 45);
            DrawNCounter(x - 70, y + 30);
            DrawNCounter(x, y + 70);
            DrawNCounter(x - 40, y + 40);

            DrawNCounter(x + 40, y + 40);

            DrawNCounter(x - 5, y - 55);

            DrawNCounter(x + 30, y - 15);
            
            if(stop!=1)
            {
                pattern++;
            }
            
        } else {

            DrawNCounter(x, y - 60);
            DrawNCounter(x - 25, y - 45);
            DrawNCounter(x - 50, y + 30);
            DrawNCounter(x, y + 70);
            DrawNCounter(x + 60, y + 35);
            DrawNCounter(x + 10, y + 45);
            DrawNCounter(x + 45, y - 45);
            DrawNCounter(x - 25, y + 25);
            
            if(stop!=1)
            {
                pattern++;
            }
        }

    }

    void DrawXNode(int x, int y) // for regions which hav less than 8 nodes
    {
        if(stop!=1)
            {
                toggle++;
            }
        
        if(toggle%2==1)
        {    
                if (s % 8 == 1) {
                    DrawNCounter(x - 40, y - 40);
                }


                if (s % 8 == 2) {
                    DrawNCounter(x + 30, y - 40);


                    DrawNCounter(x - 40, y + 40);
                }



                if (s % 8 == 3) {
                    DrawNCounter(x + 40, y + 40);

                    DrawNCounter(x - 5, y - 80);

                    DrawNCounter(x - 5, y + 75);
                }


                if (s % 8 == 4) {
                    DrawNCounter(x + 60, y);
                    DrawNCounter(x - 70, y);
                    DrawNCounter(x + 30, y - 40);
                    DrawNCounter(x - 40, y + 40);
                }


                if (s % 8 == 5) {
                    DrawNCounter(x + 40, y + 40);
                    DrawNCounter(x - 5, y - 80);
                    DrawNCounter(x - 5, y + 75);
                    DrawNCounter(x + 30, y - 40);
                    DrawNCounter(x - 40, y + 40);
                }

                if (s % 8 == 6) {
                    DrawNCounter(x + 40, y + 40);
                    DrawNCounter(x - 5, y - 80);
                    DrawNCounter(x - 5, y + 75);
                    DrawNCounter(x + 30, y - 40);
                    DrawNCounter(x - 40, y + 40);
                    DrawNCounter(x - 40, y - 40);
                }

                if (s % 8 == 7) {
                    DrawNCounter(x + 40, y + 40);
                    DrawNCounter(x - 5, y - 80);
                    DrawNCounter(x - 5, y + 75);
                    DrawNCounter(x + 30, y - 40);
                    DrawNCounter(x - 40, y + 40);
                    DrawNCounter(x - 40, y - 40);
                    DrawNCounter(x + 60, y);
                }

//                if (s % 8 == 0) {
//
//                    DrawNCounter(x - 40, y - 40);
//                    DrawNCounter(x + 30, y - 40);
//                    DrawNCounter(x - 40, y + 40);
//                    DrawNCounter(x + 40, y + 40);
//                    DrawNCounter(x - 5, y - 80);
//                    DrawNCounter(x - 5, y + 75);
//                    DrawNCounter(x + 60, y);
//                    DrawNCounter(x - 70, y);
//                }
                
                if(stop!=1)
            {
                pattern++;
            }

        }
        else
        {
           if (s % 8 == 1) {
                    DrawNCounter(x - 20, y - 60);
                }


                if (s % 8 == 2) {
                    DrawNCounter(x + 20, y + 40);


                    DrawNCounter(x - 40, y + 10);
                }



                if (s % 8 == 3) {
                    DrawNCounter(x + 55, y + 10);

                    DrawNCounter(x - 35, y - 10);

                    DrawNCounter(x - 55, y + 45);
                }


                if (s % 8 == 4) {
                    DrawNCounter(x + 10, y);
                    DrawNCounter(x - 55, y);
                    DrawNCounter(x + 10, y - 40);
                    DrawNCounter(x - 30, y + 70);
                }


                if (s % 8 == 5) {
                    DrawNCounter(x + 10, y + 54);
                    DrawNCounter(x - 5, y - 60);
                    DrawNCounter(x - 5, y + 25);
                    DrawNCounter(x - 30, y - 40);
                    DrawNCounter(x - 60, y + 40);
                }

                if (s % 8 == 6) {
                    DrawNCounter(x + 10, y + 40);
                    DrawNCounter(x - 21, y - 80);
                    DrawNCounter(x - 54, y + 55);
                    DrawNCounter(x + 60, y - 40);
                    DrawNCounter(x + 42, y + 40);
                    DrawNCounter(x - 50, y - 60);
                }

                if (s % 8 == 7) {
                    DrawNCounter(x + 10, y + 40);
                    DrawNCounter(x - 51, y - 60);
                    DrawNCounter(x +55, y + 25);
                    DrawNCounter(x + 20, y - 40);
                    DrawNCounter(x - 40, y + 50);
                    DrawNCounter(x - 70, y - 40);
                    DrawNCounter(x + 10, y);
                }

//                if (s % 8 == 0) {
//
//                    DrawNCounter(x - 10, y - 40);
//                    DrawNCounter(x + 40, y - 40);
//                    DrawNCounter(x - 70, y + 20);
//                    DrawNCounter(x + 40, y + 80);
//                    DrawNCounter(x - 15, y - 80);
//                    DrawNCounter(x - 7, y + 75);
//                    DrawNCounter(x + 30, y);
//                    DrawNCounter(x - 70, y-32);
//                }

        
        
        }
        //pattern++;


    }
    
    void findNebr(int x,int y)
    {
        x=x-174;
        y=y-150;
        h=0; 
        
        
        for(int i=0;i<c;i++)
        {
            
            
            if(( (Xhex[i] <= x+348) && (Yhex[i] <= y+300)) && ((Xhex[i] >= x) && (Yhex[i] >= y) )&&(p!=i))
            {
                nebr[p+1][h] = i+1 ;
                g.setColor(Color.black);
                g.drawString(""+nebr[p+1][h],x+80,y+110+(h*10));
                h++;
                
                g.setColor(Color.black);
                g.drawString("nebr found "+h+" "+Xhex[i]+" "+Yhex[i],x+160,y+150+(h*10));
                
                
            }
            
        } 
        
    
    
    }
    void search(int src,int des)
    {
        System.out.println("inside Search");
        search++;
            float xSrc=0;
            float ySrc=0;
            float xDes=0;
            float yDes=0;
            try{
            xSrc=XArray[src-1];
            ySrc=YArray[src-1];
            
            xDes=XArray[des-1];
            yDes=YArray[des-1];
            }
            catch(Exception e)
            {
            System.out.println("Exception caught "+e.getMessage());
            }
            int cnt;
            int routerCount=0;
            float tempx=1400;
            float tempy=1400;
            int tempCount=0;
            float slope=0;
            int quadrant=0;
//            if(xDes-xSrc==0)
//            {
//                xSrc+=100; 
//            }  
//            if(yDes-ySrc==0)
//            { 
//                ySrc+=100;
//            }
            
            //quad
            if((xDes-xSrc>=0)&&(yDes-ySrc)>=0)
            {
                quadrant=1;
                System.out.println("quad calculated= 1");
            }
            else if((xDes-xSrc<0)&&(yDes-ySrc)<0)
            {
                quadrant=3;
                System.out.println("quad calculated=  3");
            }
            else if((xDes-xSrc>=0)&&(yDes-ySrc)<0)
            {
                quadrant=4;
                System.out.println("quad calculated= 4");
            }
            else if((xDes-xSrc<0)&&(yDes-ySrc)>=0)
            {
                quadrant=2;
                System.out.println("quad calculated= 2");
                
            }
            
            if(noRouteFlag==1)
            {
                quadrant++;
                quadrant%=4;
                quadrant++;
                
            }
            try{
                
            slope=(yDes-ySrc)/(xDes-xSrc);
            System.out.println("yd-ys"+(yDes-ySrc));
            System.out.println("xd-xs"+(xDes-xSrc));
                    
            System.out.println(+slope);
            }
            catch(Exception e)
            {
            }
//            if(slope<-1)
//            {
//                if(quadrant==2){
//                    tempy=1400;
//                    tempx=  ((tempy-ySrc)/slope)+(tempy-ySrc)%slope +xSrc;
//                    tempy=1400; // equals to x- 1400
//                }
//                else if(quadrant==4)
//                {
//                    tempx=1400;
//                    tempy= -(slope * (tempx-xSrc) + ySrc);
//                    
//                    
//                }
//                
//                else
//                    System.out.println("Wrong quad");
//            }
//            else if(slope<0)
//            {   
//                if(quadrant==2)
//                {
//                    tempx=1400;
//                    tempy= slope * (tempx-xSrc) + ySrc;
//                }
//                else if(quadrant==4)
//                {
//                }
//                else
//                    System.out.println("Wrong quad");
//            
//            }
//            else if(slope<1)
//            {
//                if(quadrant==1)
//                {
//                    tempx=1400;
//                    tempy= slope * (tempx-xSrc) + ySrc;
//                }
//                else if(quadrant==3)
//                {
//                }
//                else
//                    System.out.println("Wrong quad");
//            }
//            else
//            {
//                if(quadrant==1)
//                {
//                    tempy=1400;
//                    tempx=  ((tempy-ySrc)/slope)+(tempy-ySrc)%slope +xSrc;
//                }
//                else if(quadrant==3)
//                {
//                }
//                else
//                    System.out.println("Wrong quad");
//            }
            for(int a=0;a<300;a++)
           {
               router[a]=0;
           }
            
           // System.out.println("inside Searching... searching within region x1,y1, x2, y2,  "+(xSrc+tempx)+" "+(ySrc+tempy)+" "+xSrc+" "+ySrc);
            
            switch(quadrant)
            {
                case 1:    System.out.println("quad 1");
                                searchSquare[search][1]=xSrc;
                                   searchSquare[search][2]=ySrc;
                                   searchSquare[search][3]=tempx;
                                   searchSquare[search][4]=tempy;
                
                            for(int i=0;i<s;i++)
                            {                       
                               if(( (XArray[i] <= xSrc+tempx) && (YArray[i] <= ySrc+tempy)) && ((XArray[i] >= xSrc) && (YArray[i] >= ySrc) )&&((src-1)!=i)) //make square boundary inside whuch random linking is done
                               {
                                   
                                   //System.out.println("inside Searching link within "+i+" "+(xSrc+tempx)+" "+(ySrc+tempy)+" "+xSrc+" "+ySrc);
                                   //System.out.println("fr of link = "+foragingReg[src][i]);
                                   cnt=0;
                                   while((foragingZone[src][cnt]>0) && (found!=1))
                                   {
                                       if(foragingZone[src][cnt]==i) //checks whether i is inside foraging zone array of src
                                       {    
                                       tempCount=0;
                                       while((foragingReg[i][tempCount]>0) && (found!=1) )
                                       {
                                           if(foragingReg[i][tempCount]==des || foragingReg[i][tempCount]==desG )
                                           {
                                                found=1;
                                                System.out.println("rep found inside foraging reg of"+i);
                                                if(foragingReg[i][tempCount]==des)
                                                {
                                                    System.out.println("rep of node inside foraging reg of"+i);
                                                } 
                                                else
                                                {
                                                    System.out.println("Node found inside foraging reg of"+i);
                                                }
                                                path[hopCount]=i;
                                                hopCount++;
                                                System.out.println("Found");
//                                                   System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                                   System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                                   System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                                   System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                                   System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                                   System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                                   System.out.println("                                                 found                      ");
//                                                   System.out.println("        ....                                         found                      ");
//                                                   System.out.println("                                                 found                      ");
//                                                   System.out.println("                                                 found                      ");
//                                                   System.out.println("                                                 found                      ");

                                           }
                                           tempCount++;
                                       }    
                                       //closer to node.......
                                       if((((yDes-ySrc )<500) && ((yDes-ySrc )>-500)) && (((xDes-xSrc)<500) && ((xDes-xSrc)> (-500))) && found!=1)
                                       {
                                           System.out.println("Closer to node Checking foraging zone");
                                           tempCount=0;
                                           while(foragingZone[i][tempCount]>0)
                                           {
                                               if(foragingZone[i][tempCount]==des || foragingReg[i][tempCount]==desG)
                                               {
                                                   found=1;
                                                   System.out.println("found");
//                                                   System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                                   System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                                   System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                                   System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                                   System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                                   System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                                   System.out.println("                                                 found                      ");
//                                                   System.out.println("                                                 found                      ");
//                                                   System.out.println("                                                 found                      ");
//                                                   System.out.println("                                                 found                      ");
//                                                   System.out.println("                                                 found                      ");
//                                                   System.out.println("                                                 found                      ");

                                               }
                                               tempCount++;

                                           } 

                                       }

                                       router[routerCount]=i;
                                     //  System.out.println("route found"+i+"routerCount= "+routerCount);
                                     //  System.out.println(+router[routerCount]);
                                       routerCount++;
                                       }
                                       cnt++;
                                   }

                               }
                            }
                                break;
                    
                case 2:         System.out.println("quad 2");
                                   searchSquare[search][1]=xSrc;
                                   searchSquare[search][2]=ySrc;
                                   searchSquare[search][3]=-tempx;
                                   searchSquare[search][4]=tempy;
                                for(int i=0;i<s;i++)
                                {                       
                                   if(( (XArray[i] >= (xSrc-tempx)) && (YArray[i] <= (ySrc+tempy))) && ((XArray[i] <= xSrc) && (YArray[i] >= ySrc) )&&((src-1)!=i)) //make square boundary inside whuch random linking is done
                                   {
                                       //System.out.println("inside Searching link within "+i+" "+(xSrc+tempx)+" "+(ySrc+tempy)+" "+xSrc+" "+ySrc);
                                       //System.out.println("fr of link = "+foragingReg[src][i]);
                                       cnt=0;
                                       while((foragingZone[src][cnt]>0)&& (found!=1))
                                       {
                                           if(foragingZone[src][cnt]==i) //checks whether i is inside foraging zone array of src
                                           {    
                                           tempCount=0;
                                           while((foragingReg[i][tempCount]>0) && (found!=1) )
                                           {
                                               if(foragingReg[i][tempCount]==des || foragingReg[i][tempCount]==desG )
                                               {
                                                    found=1;
                                                    System.out.println("rep found");
                                                    
                                                if(foragingReg[i][tempCount]==des)
                                                {
                                                    System.out.println("REP of node inside foraging reg of"+i);
                                                } 
                                                else
                                                {
                                                    System.out.println("NODE found inside foraging reg of"+i);
                                                }
                                                path[hopCount]=i;
                                                hopCount++;
                                                
                                                
                                                    System.out.println("Found");
                                                                      

                                               }
                                               tempCount++;
                                           }    
                                           if((((yDes-ySrc )<500) && ((yDes-ySrc )>-500)) && (((xDes-xSrc)<500) && ((xDes-xSrc)> (-500))) && (found!=1) )
                                           {
                                               System.out.println("Closer to node Checking foraging zone");
                                               tempCount=0;
                                               while(foragingZone[i][tempCount]>0)
                                               {
                                                   if(foragingZone[i][tempCount]==des || foragingReg[i][tempCount]==desG)
                                                   {
                                                       found=1;
                                                       System.out.println("Found");
                                                       
                                                   }
                                                   tempCount++;

                                               } 

                                           }

                                           router[routerCount]=i;
                                       //    System.out.println("route found"+i+"routerCount= "+routerCount);
                                        //   System.out.println(+router[routerCount]);
                                           routerCount++;
                                           }
                                           cnt++;
                                       }

                                   }
                                }
                    
                                break;
                    
                case 3:            System.out.println("quad 3");
                                    searchSquare[search][1]=xSrc;
                                   searchSquare[search][2]=ySrc;
                                   searchSquare[search][3]=-tempx;
                                   searchSquare[search][4]=-tempy;
                    
                                for(int i=0;i<s;i++)
                                {                       
                                   if(( (XArray[i] >= (xSrc-tempx)) && (YArray[i] >= (ySrc-tempy))) && ((XArray[i] <= xSrc) && (YArray[i] <= ySrc) )&&((src-1)!=i)) //make square boundary inside whuch random linking is done
                                   {
                                       //System.out.println("inside Searching link within "+i+" "+(xSrc+tempx)+" "+(ySrc+tempy)+" "+xSrc+" "+ySrc);
                                       //System.out.println("fr of link = "+foragingReg[src][i]);
                                       cnt=0;
                                       while((foragingZone[src][cnt]>0) && (found!=1))
                                       {
                                           if(foragingZone[src][cnt]==i) //checks whether i is inside foraging zone array of src
                                           {    
                                           tempCount=0;
                                           while((foragingReg[i][tempCount]>0) && (found!=1))
                                           {
                                               if(foragingReg[i][tempCount]==des || foragingReg[i][tempCount]==desG )
                                               {
                                                    found=1;
                                                    System.out.println("rep found");
                                                     if(foragingReg[i][tempCount]==des)
                                                {
                                                    System.out.println("REP of node inside foraging reg of"+i);
                                                } 
                                                else
                                                {
                                                    System.out.println("NODE found inside foraging reg of"+i);
                                                }
                                                     
                                                path[hopCount]=i;
                                                hopCount++;     
                                                     
                                                    System.out.println("Foudd");
                                                      
                                               }
                                               tempCount++;
                                           }    
                                           if((((yDes-ySrc )<500) && ((yDes-ySrc )>-500)) && (((xDes-xSrc)<500) && ((xDes-xSrc)> (-500))) && (found!=1))
                                           {
                                               System.out.println("Closer to node Checking foraging zone");
                                               tempCount=0;
                                               while(foragingZone[i][tempCount]>0)
                                               {
                                                   if(foragingZone[i][tempCount]==des || foragingReg[i][tempCount]==desG)
                                                   {
                                                       found=1;
                                                       //m.out.println("                                                 found                      ");
                                                       System.out.println("         found                      ");

                                                   }
                                                   tempCount++;

                                               } 

                                           }

                                           router[routerCount]=i;
                                       //    System.out.println("route found"+i+"routerCount= "+routerCount);
                                       //    System.out.println(+router[routerCount]);
                                           routerCount++;
                                           }
                                           cnt++;
                                       }

                                   }
                                }
                    
                                break;
                    
                    
                case 4:        System.out.println("quad 4");
                                   searchSquare[search][1]=xSrc;
                                   searchSquare[search][2]=ySrc;
                                   searchSquare[search][3]=tempx;
                                   searchSquare[search][4]=-tempy;
                    
                                for(int i=0;i<s;i++)
                                {                       
                                   if(( (XArray[i] <= (xSrc+tempx)) && (YArray[i] >= (ySrc-tempy))) && ((XArray[i] >= xSrc) && (YArray[i] <= ySrc) )&&((src-1)!=i)) //make square boundary inside whuch random linking is done
                                   {
                                       //System.out.println("inside Searching link within "+i+" "+(xSrc+tempx)+" "+(ySrc+tempy)+" "+xSrc+" "+ySrc);
                                       //System.out.println("fr of link = "+foragingReg[src][i]);
                                       
                                       cnt=0;
                                       while((foragingZone[src][cnt]>0) && (found!=1))
                                       {
                                           if(foragingZone[src][cnt]==i) //checks whether i is inside foraging zone array of src
                                           {    
                                           tempCount=0;
                                           while((foragingReg[i][tempCount]>0) && (found!=1))
                                           {
                                               if(foragingReg[i][tempCount]==des || foragingReg[i][tempCount]==desG )
                                               {
                                                    found=1;
                                                    System.out.println("rep found");
                                                     if(foragingReg[i][tempCount]==des)
                                                {
                                                    System.out.println("REP of node inside foraging reg of"+i);
                                                } 
                                                else
                                                {
                                                    System.out.println("NODE found inside foraging reg of"+i);
                                                }
                                                     
                                                path[hopCount]=i;
                                                hopCount++;
                                                
                                                
                                                    System.out.println("Found");
                                                       System.out.println("                                                 found                      ");

                                               }
                                               tempCount++;
                                           }    
                                           if((((yDes-ySrc )<500) && ((yDes-ySrc )>-500)) && (((xDes-xSrc)<500) && ((xDes-xSrc)> (-500))) && (found!=1))
                                           {
                                               System.out.println("Closer to node Checking foraging zone");
                                               tempCount=0;
                                               while(foragingZone[i][tempCount]>0)
                                               {
                                                   if(foragingZone[i][tempCount]==des || foragingReg[i][tempCount]==desG)
                                                   {
                                                       found=1;
//                                                       System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                                       System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                                       System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                                       System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                                       System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                                       System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                                       System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                                       System.out.println("                                                 found                      ");
//                                                       System.out.println("                                                 found                      ");
//                                                       System.out.println("                                                 found                      ");
//                                                       System.out.println("                                                 found                      ");
//                                                       System.out.println("                                                 found                      ");
                                                       System.out.println("                                                 found                      ");

                                                   }
                                                   tempCount++;

                                               } 

                                           }

                                           router[routerCount]=i;
                                       //    System.out.println("route found"+i+"routerCount= "+routerCount);
                                        //   System.out.println(+router[routerCount]);
                                           routerCount++;
                                           }
                                           cnt++;
                                       }

                                   }
                                }
                    
                                break;
                    
               default:     System.out.println("quad error default");   
                            break;
            
            
            }
            
            
//            for(int i=0;i<s;i++)
//             {                       
//                if(( (XArray[i] <= (xSrc+tempx)) && (YArray[i] <= (ySrc+tempy))) && ((XArray[i] >= xSrc) && (YArray[i] >= ySrc) )&&((src-1)!=i)) //make square boundary inside whuch random linking is done
//                {
//                    //System.out.println("inside Searching link within "+i+" "+(xSrc+tempx)+" "+(ySrc+tempy)+" "+xSrc+" "+ySrc);
//                    //System.out.println("fr of link = "+foragingReg[src][i]);
//                    cnt=0;
//                    while(foragingZone[src][cnt]>0)
//                    {
//                        if(foragingZone[src][cnt]==i) //checks whether i is inside foraging zone array of src
//                        {    
//                        tempCount=0;
//                        while(foragingReg[i][tempCount]>0)
//                        {
//                            if(foragingReg[i][tempCount]==des || foragingReg[i][tempCount]==desG )
//                            {
//                                 found=1;
//                                 System.out.println("rep found");
//                                 System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                    System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                    System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                    System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                    System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                    System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                    System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                    System.out.println("                                                 found                      ");
//                                    System.out.println("                                                 found                      ");
//                                    System.out.println("                                                 found                      ");
//                                    System.out.println("                                                 found                      ");
//                                    System.out.println("                                                 found                      ");
//                                   
//                            }
//                            tempCount++;
//                        }    
//                        if((((yDes-ySrc )<500) && ((yDes-ySrc )>-500)) && (((xDes-xSrc)<500) && ((xDes-xSrc)> (-500))))
//                        {
//                            System.out.println("Closer to node Checking foraging zone");
//                            tempCount=0;
//                            while(foragingZone[i][tempCount]>0)
//                            {
//                                if(foragingZone[i][tempCount]==des || foragingReg[i][tempCount]==desG)
//                                {
//                                    found=1;
//                                    System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                    System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                    System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                    System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                    System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                    System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                    System.out.println("Foooooooooooooooooooooooooooooouuuuuuuuuuuuuuunnnnnnnnnnnnnnddddddd");
//                                    System.out.println("                                                 found                      ");
//                                    System.out.println("                                                 found                      ");
//                                    System.out.println("                                                 found                      ");
//                                    System.out.println("                                                 found                      ");
//                                    System.out.println("                                                 found                      ");
//                                    System.out.println("                                                 found                      ");
//                                    
//                                }
//                                tempCount++;
//                            
//                            } 
//                        
//                        }
//                           
//                        router[routerCount]=i;
//                        System.out.println("route found"+i+"routerCount= "+routerCount);
//                        System.out.println(+router[routerCount]);
//                        routerCount++;
//                        }
//                        cnt++;
//                    }
//              
//                }
//             }
             System.out.println("Exiting Search");
             
    }
    
    
    void forRegion(int a)
    {
        forgRCount=0;
        for(int i=1;i<=s;i=i+8)
        {
            if (link[a][i]>0)
            {
            foragingReg[a][forgRCount]=i;
            //System.out.println(" foragingReg of "+a+" : "+foragingReg[a][forgRCount]);
            forgRCount++;
            
            } 
            
            
        }
                
    
                
    
    
    
    }
    
    static void forZone1(int a)
    {
        int visited=0;
        forgZCount=0;
        
        for(int i=1;i<=s;i++)
        {
                    
             if(link[a][i]>0)
            {   
                        visited=0;
                        for(int j=0;j<=forgZCount;j++)  //first check for visited
                        {
                            if(foragingZone[forgZ][j]==i)
                            {
                             visited=1;   
                            }
                        }
                        if(visited!=1)
                        {    
                        foragingZone[forgZ][forgZCount]=i; //add them to fzone array of node
                        
                    //    System.out.println("forz1: "+forgZ+" :"+foragingZone[forgZ][forgZCount]+" "+i);
                        forgZCount++;
                       // forZone2(i);
                        }
                        forZone2(i);
                     
                
            }
        }
    }
    
    
    static void forZone2(int a)
    {
        int visited;
        
        for(int i=1;i<=s;i++)
        {
             if(link[a][i]>0)
            {   
                        visited=0;
                        for(int j=0;j<=forgZCount;j++)
                        {
                            if(foragingZone[forgZ][j]==i)
                            {
                             visited=1;   
                            }
                        }
                        if(visited!=1)
                        {    
                        foragingZone[forgZ][forgZCount]=i;   
                        try{
                        forPath[forgZ][i]=a;
                        }
                        catch(Exception e){}
                        // System.out.println("forz2: "+forgZ+" :"+foragingZone[forgZ][forgZCount]+" "+i);
                        
                        forgZCount++;
                       // forZone3(i);
                        }
                       // forZone3(i);
                     
            }
        }
    }
     void forZone3(int a)   // NOT USED
    {
        int visited;
        
        for(int i=1;i<=s;i++)
        {
            if(link[a][i]>0)
            {   
                        visited=0;
                        for(int j=0;j<=forgZCount;j++)
                        {
                            try
                            {
                                if(foragingZone[forgZ][j]==i)
                                {
                                visited=1;   
                                }
                            }
                            catch(ArrayIndexOutOfBoundsException e)
                            {
                            System.out.println(""+e.getMessage());
                            }
                        }
                        if(visited!=1)
                        { 
                         try{   
                        foragingZone[forgZ][forgZCount]=i;                       
                      //  System.out.println("forz3: "+forgZ+" :"+foragingZone[forgZ][forgZCount]+" "+i);
                         }
                         catch(ArrayIndexOutOfBoundsException e)
                         {
                             System.out.println(""+e.getMessage());
                         }
                         forgZCount++;
                        
                        }
                     
            }
        }
    }
    void linkingRep(int a)
    {
    int x,y;
        
        int e=0;
        int d[]=new int[8000];
        int local;
        int local2;
        int rand;
        int rand2;
        
        
        if(s>2500)
        { 
            x=XArray[a-1] - 1000;
            y=YArray[a-1] - 1000;
            for(int i=0;i<s;i++)
            {


                    if(( (XArray[i] <= x+2000) && (YArray[i] <= y+2000)) && ((XArray[i] >= x) && (YArray[i] >= y) )&&((a-1)!=i)) //make square boundary inside whuch random linking is done
                    {
                        if((XArray[i]>x+600) && (XArray[i]<x+1400) && (YArray[i]>y+600) && (YArray[i]<y+1400) && s>2500)
                        {
                            
                        }
                                    else
                                    {    
                                        local=a/8;
                                        local2=a%8;
                                    // to restrict linking wothin region... nodes inside same region are determined and all others are assembled in an array to choose from

                                            if(local2!=0)       
                                            {
                                                if(((i+1)<=((local*8)+8)) && ((i+1)>(local*8)))
                                                { }
                                                else if((i+1)%8==1)
                                                {
                                                    d[e]=i+1;    // d[e] stores all the nodes inside square of node a in an array
                                                    e++;
                                                }
                                                else
                                                {

                                                }
                                            }
                                            else
                                            {
                                                    if(((i+1)<=(local*8)) && ((i+1) >((local-1) * 8)))
                                                    {  }
                                                    else if((i+1)%8==1)
                                                    {
                                                        d[e]=i+1;
                                                        e++;
                                                    }

                                                    else
                                                    {

                                                    }


                                            }
                             }       

                    }  

               }
           }
        else //if s<2500
            {
                x=XArray[a-1] - 1000;
                 y=YArray[a-1] - 1000;
                for(int i=0;i<s;i++)
                 {


                    if(( (XArray[i] <= x+2000) && (YArray[i] <= y+2000)) && ((XArray[i] >= x) && (YArray[i] >= y) )&&((a-1)!=i) ) //make square boundary inside whuch random linking is done
                    {
                        
                        
                        {
                                    local=a/8;
                                    local2=a%8;
                                    // to restrict linking wothin region... nodes inside same region are determined and all others are assembled in an array to choose from

                                    if(local2!=0)       
                                    {
                                            if(((i+1)<=((local*8)+8)) && ((i+1)>(local*8)))
                                            { }
                                            else if((i+1)%8==1)
                                            {
                                                d[e]=i+1;    // d[e] stores all the nodes inside square of node a in an array
                                                e++;
                                            }
                                            else
                                            {

                                            }
                                    }
                                    else
                                    {
                                            if(((i+1)<=(local*8)) && ((i+1) >((local-1) * 8)))
                                            {  }
                                            else if((i+1)%8==1)
                                            {
                                                d[e]=i+1;
                                                e++;
                                            }

                                            else
                                            {

                                            }


                                    }
                        
                            }
                       }  

                  }
        
        
            }   
        
        
                     int lnk=0;
                     float rand3=0;
                     float temp1;
                     float temp2;
                   if(s>2000)
                   {  
                            for(int q=0;q<6;q++)
                            {    

                                rand=(int)(Math.random() * (e));
                                lnk=d[rand];        //choose random from d[e] array i.e. nodes inside sq. 

                                rand2=(int)(Math.random() * (15));   //bandwidth

                                 link[a][lnk]=(rand2+20);
                                 link[lnk][a]=(rand2+20);
                                
                                 //!!........Delay..........!!
                                 rand3=(float)(Math.random() * (10));
                             temp1=a;
                            temp2=lnk;
//                         rand3*=560;
                         rand3/=2;
                      //   System.out.println("rand="+(rand3+1));
                         forCost[lnk][a]=rand3+1;
                         forCost[a][lnk]=rand3+1;
                                 try
                                 {    
                                // System.out.println("end a: "+a+"-->"+lnk +" : "+(rand2+1));  

//                                 g.setColor(Color.black);
                        //         g.drawLine(XArray[a-1]+5, YArray[a-1]+5, XArray[lnk-1]+5, YArray[lnk-1]+5);  //+5 to adjust lines at centre
                                 }
                                 catch(Exception exp)
                                 {
                                 System.out.println(exp.getMessage());
                                 }
                            }
                   }
                   else
                   {
                        for(int q=0;q<3;q++)
                            {    

                                rand=(int)(Math.random() * (e));
                                lnk=d[rand];        //choose random from d[e] array i.e. nodes inside sq. 

                                rand2=(int)(Math.random() * (15));   //bandwidth

                                 link[a][lnk]=(rand2+20);
                                 link[lnk][a]=(rand2+20);
                                   //!!........Delay..........!!
                                 rand3=(float)(Math.random() * (10));
                             temp1=a;
                            temp2=lnk;
//                         rand3*=500;
                         rand3/=2;
                      ///   System.out.println("rand="+(rand3+1));
                         forCost[lnk][a]=rand3+1;
                         forCost[a][lnk]=rand3+1;
                                 try
                                 {    
                                // System.out.println("end a: "+a+"-->"+lnk +" : "+(rand2+1));  

                                // g.setColor(Color.black);
                              //   g.drawLine(XArray[a-1]+5, YArray[a-1]+5, XArray[lnk-1]+5, YArray[lnk-1]+5);  //+5 to adjust lines at centre
                                 }
                                 catch(Exception exp)
                                 {
                                 System.out.println(exp.getMessage());
                                 }
                            }
                   
                   
                   
                   }
                    //linking representative node to all other nodes
                    for(int q=a+1;q<a+8;q++)
                    {
                         rand=(int)(Math.random() * (10));
                         link[a][q]=rand+10;       //rand also generates zero so add 10 to make it atleast 11
                         link[q][a]=rand+10;
                         
                         
                    }
    }
    void linking(int a)
    {
//        
//        g.drawLine(XArray[a-1], YArray[a-1], XArray[a+10], YArray[a+10]);
//        g.drawLine(XArray[a-1], YArray[a-1], XArray[a+60], YArray[a+60]);
//        g.drawLine(XArray[a-1], YArray[a-1], XArray[a+40], YArray[a+40]);
        
//        for(int b=0;b<1;b++)
//        {    
//        int rand=(int)(Math.random() * s);
//         g.drawString(""+rand+1, 50, 160);
//         link[a][rand+1]=1;
//         
//         
//         link[rand+1][a]=1;
//        g.drawLine(XArray[a-1], YArray[a-1], XArray[rand], YArray[rand]);
//        }
        int x,y;
        
        int e=0;
        int d[]=new int[8000];
        int local;
        int local2;
        int rand;
        int rand2;
        
        x=XArray[a-1] - 250;
        y=YArray[a-1] - 250;
        for(int i=0;i<s;i++)
        {
            
            
                if(( (XArray[i] <= x+500) && (YArray[i] <= y+500)) && ((XArray[i] >= x) && (YArray[i] >= y) )&&((a-1)!=i)) //make square boundary inside whuch random linking is done
                {
                    local=a/8;
                    local2=a%8;
                    // to restrict linking wothin region... nodes inside same region are determined and all others are assembled in an array to choose from
                    
                    if(local2!=0)       
                    {
                        if(((i+1)<=((local*8)+8)) && ((i+1)>(local*8)))
                        { }
                        else if((i+1)%8==1)
                        {
                        }
                        else
                        {
                            d[e]=i+1;    // d[e] stores all the nodes inside square of node a in an array
                            e++;
                        }
                    }
                    else
                    {
                        if(((i+1)<=(local*8)) && ((i+1) >((local-1) * 8)))
                        {  }
                        else if((i+1)%8==1)
                        {
                        }
                        
                        else
                        {
                            d[e]=i+1;
                            e++;
                        }
                       
                   
                    }
               
                }  
            
           }
        
                     int lnk=0;
                     float rand3=0;
                     float temp1;
                     float temp2;
                    for(int q=0;q<3;q++)
                    {    
                        
                        rand=(int)(Math.random() * (e));
                        lnk=d[rand];        //choose random from d[e] array i.e. nodes inside sq. 
                        
                        rand2=(int)(Math.random() * (10));   //bandwidth
                        
                         link[a][lnk]=(rand2+1);
                         link[lnk][a]=(rand2+1);
                         
                         //!!..........Delay.......!!!
                         
                         rand3=(float)(Math.random() * (10));
                         temp1=a;
                         temp2=lnk;
                        // rand3*=500;
                         rand3/=2;
                        // System.out.println("rand="+(rand3+1));
                         forCost[lnk][a]=rand3+1;
                         forCost[a][lnk]=rand3+1;
                         try
                         {    
                         //System.out.println("end a: "+a+"-->"+lnk +" : "+(rand2+1));  
                        // g.setColor(Color.magenta);
                  //       g.drawLine(XArray[a-1]+5, YArray[a-1]+5, XArray[lnk-1]+5, YArray[lnk-1]+5);  //+5 to adjust lines at centre
                         }
                         catch(Exception exp)
                         {
                         System.out.println(exp.getMessage());
                         }
                    }
                    
              
    }

    void DrawHexagon(int x, int y) {
        //g.setColor(Color.blue);  
        //g.drawString("R"+counter,x,y);
       /* g.setColor(Color.BLACK);
         g.drawLine(x,y-100,x-87,y-50);
         g.drawLine(x-87,y-50,x-87,y+50);
         g.drawLine(x-87,y+50,x,y+100);
         g.drawLine(x,y+100,x+87,y+50);
         g.drawLine(x+87,y+50,x+87,y-50);
         g.drawLine(x+87,y-50,x,y-100);   */
        counter++;
        
        
        Polygon poly = new Polygon();  // declare and create
        poly.addPoint(x - 87, y - 50);  // add points to polygon
        poly.addPoint(x - 87, y + 50);
        poly.addPoint(x, y + 100);
        poly.addPoint(x + 87, y + 50);
        poly.addPoint(x + 87, y - 50);
        poly.addPoint(x, y - 100);
        

        g.setColor(Color.cyan);
        g.fillPolygon(poly);   //colouring pollygon..
        g.setColor(Color.red);
        g.drawPolygon(poly);    // polygon boundary

        //xternal gateway

//        g.setColor(Color.MAGENTA);
//        g.fillOval(x + 42, y - 79, 10, 8);
//        g.fillOval(x - 45, y - 79, 10, 8);
//        g.fillOval(x - 90, y - 4, 8, 10);
//        g.fillOval(x - 45, y + 71, 10, 8);
//        g.fillOval(x + 42, y + 71, 10, 8);
//        g.fillOval(x + 84, y - 4, 8, 10);

        //REgion no.
        g.setColor(Color.blue);
        g.drawString("R" + counter, x, y - 15);
        
         regionNumber[c]=pattern;
        // g.drawString("pat="+regionNumber[c], x, y);
         
         
         Xhex[c]=x;
         Yhex[c]=y;
        //  g.drawString("hex="+Xhex[c]+" "+Yhex[c], x+10, y+10);       
         c++;
       

//       ex2.CraftingPanel cp = new ex2.CraftingPanel();
//       cp.paintComponent(g,x-10,y-5);


        /*     g.setColor(Color.GREEN);
         g.drawLine(x,y-100,x-87,y-50);
         g.drawLine(x-87,y-50,x-87,y+50);
         g.drawLine(x-87,y+50,x,y+100);
         g.drawLine(x,y+100,x+87,y+50);
         g.drawLine(x+87,y+50,x+87,y-50);
         g.drawLine(x+87,y-50,x,y-100);   */

    }

    public void nodeRepaint() {
        g = design.getGraphics();
        design.paint(g);
        infoFlag = 0;
        repaint();
        try {

            for (int p = 0; p < 1000; p++) {
                Thread.sleep(400);
                if (stop == 1) {
                    break;
                }
                repaint();

                // g.drawString("repainting",200,500);
                //Thread.sleep(500);
                //g.drawString("repainting sanket",200,x);
                //x+=10;
                //  g.drawString("repaint counter =" +repaintcounter,300,600);
            }
        } catch (InterruptedException e) {
             g.drawString(e.getMessage(),200,400);
        }
    }
}
